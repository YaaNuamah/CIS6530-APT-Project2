#!/usr/bin/env python3

import os
import subprocess
import logging
from pathlib import Path
import shutil
import time

class OpcodeExtractor:
    def __init__(self):
        # Adjust paths as needed
        self.input_dir = Path("/home/kali/apt_analysis/malware/executables/G0014_NightDragon")
        self.output_dir = Path("/home/kali/apt_analysis/output/G0014_NightDragon")
        self.temp_dir = self.output_dir / "temp"
        self.ghidra_headless = "/usr/share/ghidra/support/analyzeHeadless"
        self.script_path = "/usr/share/ghidra/Ghidra/Features/Base/ghidra_scripts/ExtractOpCodes.class"
        
        # Configure logging
        self.setup_logging()
        
        # Initialize directories
        self.setup_directories()

    def setup_logging(self):
        """Setup logging configuration"""
        log_file = self.output_dir / "extraction.log"
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_file),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)

    def setup_directories(self):
        """Create necessary directories"""
        self.output_dir.mkdir(parents=True, exist_ok=True)
        self.temp_dir.mkdir(parents=True, exist_ok=True)

    def process_file(self, file_path):
        """Process a single malware file with Ghidra"""
        project_name = f"Project_{file_path.stem}"
        project_dir = self.temp_dir / project_name

        output_file = self.output_dir / f"{file_path.stem}.opcode"

        # Skip if output file already exists
        if output_file.exists() and output_file.stat().st_size > 0:
            self.logger.info(f"Skipping {file_path.name} - already processed")
            return True

        # Create project directory
        project_dir.mkdir(parents=True, exist_ok=True)

        self.logger.info(f"Processing {file_path.name}...")
        self.logger.info(f"Output will be saved to: {output_file}")

        # Run Ghidra headlessly
        cmd = [
            self.ghidra_headless,
            str(project_dir),
            project_name,
            "-import", str(file_path),
            "-postScript", "ExtractOpCodes",
            str(output_file),
            "-deleteProject"
        ]

        try:
            process = subprocess.run(cmd, capture_output=True, text=True, check=True)
            self.logger.info(f"Successfully processed {file_path.name}")
            if output_file.exists() and output_file.stat().st_size > 0:
                self.logger.info(f"Created output file: {output_file.name}")
                return True
            else:
                self.logger.error(f"Failed to create output file for {file_path.name}")
                return False
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Error processing {file_path.name}")
            self.logger.error(f"Ghidra stderr:\n{e.stderr}")
            return False
        finally:
            # Clean up the project directory to save memory
            if project_dir.exists():
                shutil.rmtree(project_dir)

    def run(self):
        """Run the extraction process"""
        files = list(self.input_dir.glob("*"))
        total_files = len(files)
        processed_files = 0

        self.logger.info(f"Found {total_files} files to process in {self.input_dir}")

        for i, file_path in enumerate(files, 1):
            self.logger.info(f"Processing file {i}/{total_files}: {file_path.name}")
            success = self.process_file(file_path)
            if success:
                processed_files += 1
            time.sleep(0.5)  # Brief pause for stability

        self.logger.info("Extraction Summary")
        self.logger.info(f"Total files processed: {processed_files}/{total_files}")

if __name__ == "__main__":
    extractor = OpcodeExtractor()
    extractor.run()
